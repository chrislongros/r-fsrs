---
title: "Getting Started with rfsrs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with rfsrs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

**rfsrs** provides R bindings for the FSRS (Free Spaced Repetition Scheduler) algorithm. FSRS is a modern spaced repetition algorithm that models human memory more accurately than traditional algorithms like SM-2.

This vignette will introduce you to the core concepts and show you how to use rfsrs for scheduling flashcard reviews.

```{r setup}
library(rfsrs)
```

## Understanding FSRS

### The Memory Model

FSRS models memory using two key variables:

1. **Stability (S)**: Represents how long a memory will last. Higher stability means slower forgetting. Specifically, stability is the number of days until retrievability drops to 90%.

2. **Difficulty (D)**: Represents how hard the material is to learn. Ranges from 1-10. Higher difficulty means stability grows more slowly with each review.

### Retrievability

Retrievability is the probability that you can recall a memory at a given time. It follows the forgetting curve:

$$R(t) = \left(1 + \frac{t}{9S}\right)^{-1}$$

Where $t$ is elapsed time in days and $S$ is stability.

```{r forgetting-curve}
# Visualize the forgetting curve for different stability values
stability_values <- c(1, 5, 10, 30)
days <- 0:60

# Create data for plotting
curves <- lapply(stability_values, function(s) {
  data.frame(
    day = days,
    retrievability = sapply(days, function(d) fsrs_retrievability(s, d)),
    stability = paste("S =", s, "days")
  )
})
curve_data <- do.call(rbind, curves)

# Simple base R plot
plot(NULL, xlim = c(0, 60), ylim = c(0, 1),
     xlab = "Days since last review", ylab = "Retrievability",
     main = "Forgetting Curves for Different Stability Values")
colors <- c("red", "orange", "blue", "green")
for (i in seq_along(stability_values)) {
  s <- stability_values[i]
  r <- sapply(days, function(d) fsrs_retrievability(s, d))
  lines(days, r, col = colors[i], lwd = 2)
}
legend("topright", legend = paste("S =", stability_values, "days"), 
       col = colors, lwd = 2)
abline(h = 0.9, lty = 2, col = "gray")
text(55, 0.92, "90% threshold", cex = 0.8)
```

## Basic Usage

### Creating a New Card

When you first learn a card, you create an initial memory state based on your first rating:

```{r initial-state}
# Rating scale: 1=Again, 2=Hard, 3=Good, 4=Easy
state <- fsrs_initial_state(rating = 3)  # First review, rated "Good"
print(state)
```

The initial stability depends on your rating - higher ratings give higher initial stability:

```{r compare-initial}
ratings <- 1:4
rating_names <- c("Again", "Hard", "Good", "Easy")

for (i in ratings) {
  s <- fsrs_initial_state(rating = i)
  cat(sprintf("%s (rating=%d): stability=%.2f, difficulty=%.2f\n",
              rating_names[i], i, s$stability, s$difficulty))
}
```

### Checking Retrievability

After a review, you can check how well you'll remember the card over time:

```{r check-retrievability}
state <- fsrs_initial_state(rating = 3)

cat("Retrievability after:\n")
for (days in c(1, 3, 7, 14, 30)) {
  r <- fsrs_retrievability(state$stability, elapsed_days = days)
  cat(sprintf("  %2d days: %.1f%%\n", days, r * 100))
}
```

### Getting the Next Interval

FSRS calculates the optimal interval for your next review:

```{r next-interval}
state <- fsrs_initial_state(rating = 3)

# What interval should we use for each possible rating?
for (rating in 1:4) {
  interval <- fsrs_next_interval(state$stability, state$difficulty, rating)
  cat(sprintf("If you rate '%s': review in %d days\n", 
              rating_names[rating], round(interval)))
}
```

### Simulating a Review

After reviewing a card, update the memory state:

```{r next-state}
# Initial state
state <- fsrs_initial_state(rating = 3)
cat(sprintf("Initial: stability=%.2f\n", state$stability))

# Review after 2 days, rate "Good"
state <- fsrs_next_state(
  stability = state$stability,
  difficulty = state$difficulty,
  rating = 3,
  elapsed_days = 2
)
cat(sprintf("After review 1: stability=%.2f\n", state$stability))

# Review after 5 days, rate "Good"
state <- fsrs_next_state(
  stability = state$stability,
  difficulty = state$difficulty,
  rating = 3,
  elapsed_days = 5
)
cat(sprintf("After review 2: stability=%.2f\n", state$stability))
```

## Simulating Long-term Learning

Let's simulate learning a card over many reviews:

```{r simulate-learning}
simulate_learning <- function(n_reviews = 10, rating = 3) {
  state <- fsrs_initial_state(rating = rating)
  
  results <- data.frame(
    review = 0,
    day = 0,
    stability = state$stability,
    difficulty = state$difficulty,
    interval = NA
  )
  
  current_day <- 0
  
  for (i in 1:n_reviews) {
    interval <- fsrs_next_interval(state$stability, state$difficulty, rating)
    current_day <- current_day + interval
    state <- fsrs_next_state(state$stability, state$difficulty, rating, interval)
    
    results <- rbind(results, data.frame(
      review = i,
      day = current_day,
      stability = state$stability,
      difficulty = state$difficulty,
      interval = interval
    ))
  }
  
  return(results)
}

# Simulate 10 reviews, always rating "Good"
learning <- simulate_learning(n_reviews = 10, rating = 3)
print(learning)
```

```{r plot-learning}
# Plot stability growth
plot(learning$review, learning$stability, type = "b", pch = 19,
     xlab = "Review Number", ylab = "Stability (days)",
     main = "Stability Growth Over Reviews")
grid()
```

```{r plot-intervals}
# Plot interval growth (excluding first row which has NA)
intervals <- learning$interval[-1]
plot(1:length(intervals), intervals, type = "b", pch = 19,
     xlab = "Review Number", ylab = "Interval (days)",
     main = "Review Interval Growth")
grid()
```

## Effect of Difficulty

Cards with different difficulty levels grow stability at different rates:

```{r difficulty-effect}
# Compare easy vs difficult cards
set.seed(42)

simulate_with_difficulty <- function(initial_rating, ongoing_rating, n = 10) {
  state <- fsrs_initial_state(rating = initial_rating)
  stabilities <- state$stability
  
  for (i in 1:n) {
    interval <- fsrs_next_interval(state$stability, state$difficulty, ongoing_rating)
    state <- fsrs_next_state(state$stability, state$difficulty, ongoing_rating, interval)
    stabilities <- c(stabilities, state$stability)
  }
  
  return(stabilities)
}

# Easy card (high initial rating, then Good)
easy_card <- simulate_with_difficulty(initial_rating = 4, ongoing_rating = 3)

# Hard card (low initial rating, then Good)
hard_card <- simulate_with_difficulty(initial_rating = 2, ongoing_rating = 3)

# Plot comparison
plot(0:10, easy_card, type = "b", pch = 19, col = "blue",
     xlab = "Review Number", ylab = "Stability (days)",
     main = "Stability Growth: Easy vs Hard Cards",
     ylim = c(0, max(easy_card, hard_card)))
lines(0:10, hard_card, type = "b", pch = 19, col = "red")
legend("topleft", legend = c("Easy start", "Hard start"),
       col = c("blue", "red"), pch = 19, lty = 1)
grid()
```

## FSRS Parameters

FSRS uses 21 parameters that control the algorithm's behavior:

```{r parameters}
params <- fsrs_default_parameters()
cat("FSRS-6 default parameters:\n")
print(params)
```

These parameters can be optimized for individual users based on their review history. The rfsrs package currently uses the default parameters, which work well for most users.

## Summary

Key takeaways:

1. **Stability** represents memory durability and grows with successful reviews
2. **Difficulty** affects how quickly stability grows
3. **Retrievability** is the probability of recall, following a forgetting curve
4. Use `fsrs_initial_state()` for new cards, `fsrs_next_state()` after reviews
5. Use `fsrs_next_interval()` to schedule the next review
6. Use `fsrs_retrievability()` to check current recall probability

For more information, see:

- [ABC of FSRS](https://github.com/open-spaced-repetition/fsrs4anki/wiki/ABC-of-FSRS)
- [fsrs-rs documentation](https://github.com/open-spaced-repetition/fsrs-rs)
